{
  "tasks": [
    {
      "id": 2,
      "title": "What is Software? Types of Software‚Äôs?",
      "description": "",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-19T23:54:50.212Z",
      "startDate": "2026-01-18",
      "dueDate": "2026-01-18",
      "deadlineStatus": "overdue"
    },
    {
      "id": 3,
      "title": "What is Software Testing?",
      "description": "Software testing a part of developing a software and making sure the software is working as per the requirement of user or customer request or needs",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-22T21:12:59.310Z",
      "startDate": "2026-01-18",
      "dueDate": "2026-01-20",
      "deadlineStatus": "overdue"
    },
    {
      "id": 4,
      "title": "What is Software Quality?",
      "description": "What is software Testing Quality? the objective of testing is to release quality product to the client and  Software testing quality  should be \n1. Bug free\n2. Delivered on Time\n3. Within Budget.\n4. Meets requirements and or expectations of customers\n5. Maintainable ",
      "priority": "High",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-22T21:12:54.457Z",
      "startDate": "",
      "dueDate": "",
      "deadlineStatus": "normal"
    },
    {
      "id": 5,
      "title": "Project Vs Product",
      "description": "",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-19T23:55:24.630Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 6,
      "title": "Why do we need Testing?",
      "description": "",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-19T23:55:57.169Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 7,
      "title": "Error, Bug & Failure",
      "description": "",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-19T23:55:59.384Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 8,
      "title": "Why the software has bugs?",
      "description": "",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-19T23:56:00.818Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 9,
      "title": "SDLC ",
      "description": "The SDLC (Software Development Life Cycle) is a structured process used to plan, build, test, deploy, and maintain software. It ensures software is delivered with quality, on time, and within budget.\nüîπ SDLC Process (Simple & Clear)\n1. Requirement Gathering\nUnderstand what the customer wants.\n\nDocument all functional and non‚Äëfunctional requirements.\n\n2. Feasibility Study\nCheck if the project is technically, financially, and operationally possible.\n\n3. System Design\nCreate high‚Äëlevel and low‚Äëlevel designs.\n\nDecide architecture, database design, UI design, and technology stack.\n\n4. Implementation / Coding\nDevelopers write the actual code based on the design.\n\n5. Testing\nTesters verify the software for defects.\n\nIncludes unit, integration, system, and acceptance testing.\n\n6. Deployment\nRelease the software to production for end users.\n\n7. Maintenance\nFix issues, update features, and improve performance after release.",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-22T21:20:54.969Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 10,
      "title": "Waterfall Model",
      "description": "Requirement Analysis  \nGather and document all system requirements from stakeholders.\n\nSystem Design  \nTranslate requirements into architecture and design specifications.\n\nImplementation  \nDevelop the actual software code based on the design.\n\nTesting  \nVerify and validate the software to ensure it meets requirements and is bug-free.\n\nDeployment  \nRelease the software to the production environment for end users.\n\nMaintenance  \nProvide ongoing support, updates, and bug fixes after deployment.\n‚úÖ Advantages of the Waterfall Model\nHigh product quality due to structured development.\n\nFewer bugs since requirement changes are restricted.\n\nLower initial investment‚Äîtesters are hired in later stages.\n\nIdeal for small projects with fixed requirements.\n\n‚ö†Ô∏è Disadvantages of the Waterfall Model\nNo flexibility for changing requirements.\n\nEarly requirement defects persist through later phases.\n\nHigher total cost due to time-consuming rework.\n\nTesting begins only after coding is complete.",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-22T21:04:50.493Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 11,
      "title": "Spiral Model",
      "description": "üîÑ Spiral Model ‚Äì Overview\nThe Spiral Model is an iterative software development model.\n\nIt was designed to overcome the limitations of the Waterfall Model.\n\nIt is used when there is module dependency in the system.\n\nIn each cycle, new software is released to the customer.\n\nSoftware is delivered in multiple versions, which is why it‚Äôs also called a version control model.\n\n‚úÖ Advantages of the Spiral Model\nTesting occurs in every cycle before moving to the next.\n\nCustomers can use software for each module, gaining early access.\n\nRequirement changes are allowed after each cycle, offering flexibility.\n‚ö†Ô∏è Disadvantages of the Spiral Model\nRequirement changes are not allowed during a cycle ‚Äî only between cycles.\n\nEach cycle resembles the Waterfall Model, which may limit agility.\n\nNo testing is done during the requirement and design phases, potentially allowing early issues to persist.",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-22T21:08:39.044Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 12,
      "title": "V-Model",
      "description": "üîç Verification\nEnsures we are building the product right.\n\nFocuses on documentation.\n\nHappens before validation.\n\nInvolves activities like reviews, walkthroughs, and inspections.\n\n‚úÖ Validation\nEnsures we are building the right product.\n\nFocuses on the actual software.\n\nTakes place after verification.\n\nInvolves unit testing, integration testing, system testing, and UAT.\n",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-22T22:07:24.690Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 13,
      "title": "QA & QC & QE",
      "description": "QA is process related.\nQC is the actual testing of the software.\n\nQA focuses on building in quality.\nQC focuses on testing for quality.\n\nQA is preventing defects.\nQC is detecting defects.\n\nQA is process oriented.\nQC is product oriented.\n\nQA is for the entire life cycle.\nQC is for the testing part of SDLC.\n‚úÖ QA (Quality Assurance)\nProcess-oriented: Focuses on improving and defining processes to prevent defects.\n\nGoal: Build quality into the product from the start.\n\nResponsibility: Often involves managers, analysts, and process designers.\n\nExample activities: Process audits, documentation reviews, training, standards enforcement.\n\n‚úÖ QC (Quality Control)\nProduct-oriented: Involves actual testing of the software to find defects.\n\nGoal: Verify that the product meets quality requirements.\n\nResponsibility: Typically performed by testers and QA engineers.\n\nExample activities: Manual testing, automation, bug reporting, regression testing.\n\nüîÅ The \"p - people / process / product\" line:\nPeople ‚Üí QC (Testers): Testers execute tests and validate the product.\n\nProcess ‚Üí QA: QA defines and improves the process to ensure quality.\n\nProduct: The final software output, shaped by both QA and QC efforts.\nPlease Note: QC is like manual tester sometime do automation testing \nwhile QE Quality Engineer is Automation Tester who write code ",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-22T22:02:36.016Z",
      "deadlineStatus": "normal",
      "startDate": "",
      "dueDate": "",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Levels of Software Testing",
      "description": "1. Unit Testing ‚Äì Example  \nA developer tests a single function, like calculateTotal(), to ensure it returns the correct value for different inputs.\n\n2. Integration Testing ‚Äì Example  \nAfter combining the Login module and the User Dashboard module, testers verify that a user can log in and the correct dashboard loads without errors.\n\n3. System Testing ‚Äì Example  \nTesters validate the entire e‚Äëcommerce application end‚Äëto‚Äëend: browsing products, adding to cart, checkout, payment, and order confirmation.\n\n4. Acceptance Testing ‚Äì Example  \nBusiness users perform UAT to confirm the system meets their needs ‚Äî for example, verifying that a refund workflow matches the company‚Äôs real business process.",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-22T22:10:33.939Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 15,
      "title": "White Box & Black Box Testing",
      "description": "Black Box Testing\nBlack Box Testing focuses on what the application does, not how it works internally.\nKey Points\n- Tester does not know the internal code, logic, or structure\n- Testing is based on requirements, inputs, and outputs\n- You treat the system like a ‚Äúblack box‚Äù ‚Äî only the UI or API behavior matters\nExamples\n- Functional testing\n- Smoke testing\n- Regression testing\n- Boundary value analysis\n- Equivalence partitioning\nWhen used\n- During System Testing, Acceptance Testing, and UAT\n\n‚ö™ White Box Testing\nWhite Box Testing focuses on how the application works internally ‚Äî code, logic, and structure.\nKey Points\n- Tester knows the internal code, logic, loops, conditions, and paths\n- Testing is based on code coverage\n- Usually done by developers or SDETs with code access\nExamples\n- Unit testing\n- Code coverage testing\n- Path testing\n- Loop testing\n- Condition/decision testing\nWhen used\n- During Unit Testing and sometimes Integration Testing\n",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-25T17:15:23.451Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 16,
      "title": "Static Testing & Dynamic Testing",
      "description": "",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-25T22:27:54.814Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 17,
      "title": "Verification & Validation",
      "description": "",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-25T22:28:03.256Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 18,
      "title": "System Testing Types",
      "description": "System Testing\nSystem testing is the process of testing the complete functionality of an application based on the client‚Äôs requirements. It is a black-box testing technique performed by the testing team. This type of testing is conducted after component testing and integration testing. It requires a clear understanding of customer requirements and expectations.\nSystem testing focuses on the following aspects:\n- User Interface Testing (GUI)\n- Functional Testing\n- Non-Functional Testing\n- Usability Testing\n",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-23T14:40:41.394Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 19,
      "title": "GUI Testing",
      "description": "User Interface Testing (GUI) focuses on verifying that the graphical elements of an application function correctly and meet design specifications. It ensures that:\n- üñ±Ô∏è All UI components (buttons, menus, icons, forms) are present, responsive, and behave as expected.\n- üé® Visual consistency is maintained across screens‚Äîfonts, colors, spacing, and alignment match the design.\n- üì± Cross-platform compatibility is validated‚ÄîUI behaves properly on different devices, browsers, and resolutions.\n- üß™ Interactive elements respond to user actions like clicks, hovers, and keyboard input.\n- üö´ Error messages and validations appear correctly when users input invalid data.\n- üîç Accessibility standards are met‚Äîscreen readers, keyboard navigation, and contrast ratios are tested.\n",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-25T16:18:57.841Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 20,
      "title": "Functional",
      "description": "Functionality Testing\n1)- Object Properties Testing\nExample: Check if the ‚ÄúSubmit‚Äù button is enabled only after all required fields are filled.\n2)- Database Testing\nExample: Verify that a new user registration correctly inserts data into the users table.\n- Error Handling\nExample: Enter invalid email format and confirm the system shows a clear error message.\n3)- Calculations / Manipulations Testing\nExample: Add items to cart and verify the total price is calculated correctly with tax and discount.\n4)- Links Existence & Links Execution\nExample: Confirm that the ‚ÄúForgot Password‚Äù link is visible and navigates to the correct page.\n5)- Cookies & Sessions\nExample: Log in and check that a session cookie is created and persists until logout.\nüç™ Cookies\nTemporary files created by the browser while browsing pages on the internet.\n‚è≥ Sessions\nTime slots created by the server. A session will expire after some time (especially if you're idle).\n\n\n",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-25T16:57:49.421Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 21,
      "title": "Test Design Techniques",
      "description": "Test design techniques are structured methods used to create effective test cases that maximize coverage while minimizing effort. They help QA engineers identify what to test, how to test it, and ensure that critical scenarios are not missed.\n . They help QA engineers identify what to test, how to test it, and ensure that critical scenarios are not missed.\n\nüß™ What Is a Test Design Technique?\nTest design techniques are part of the test planning phase in software testing. They guide testers in selecting test conditions, creating test cases, and organizing test data to validate software functionality efficiently.\nüéØ Purpose\n- Improve test coverage\n- Reduce redundant test cases\n- Catch edge cases and hidden bugs\n- Ensure system reliability\nfor example there is a age text box and it should accept data between 18-35 so we before applying test designee technique we have to check the invalid data before 18 and valid data between 18-35 and again invalid data after 35-& so if we apply test designee technique there is simple function the apply for it which will sample check the entered data whither it's valid or no ",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-26T14:53:20.640Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 22,
      "title": "Re-Testing",
      "description": " Re-Testing\nRe-testing is performed when a developer fixes a bug and the tester verifies the fix.\nProcess:\n- If the bug is resolved, the tester closes it.\n- If the bug is not resolved, the tester re-opens it and sends it back to the developer.\nPurpose:\nTo ensure that previously identified defects are fixed in the current build.\nExample:\n- Build 1.0 was released.\n- Test team found defects (Defect IDs: 1.0.1, 1.0.2) and posted them.\n- Build 1.1 was released.\n- Testing defects 1.0.1 and 1.0.2 in Build 1.1 is called Re-testing.\n",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-25T18:10:44.182Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 23,
      "title": "Exploratory Testing",
      "description": "Exploratory Testing is a testing that we don't have the documents and don't involved in with developer we will make a file as we start testing it one by one \nExploratory Testing\n- We explore the application, understand it completely, and then test it.\n- Understand the application, identify all possible scenarios, document them, and use them for testing.\n- Exploratory testing is done when the application is ready but there are no formal requirements.\n- Test engineers perform exploratory testing in the absence of documented requirements.\nDrawbacks:\n- You might misunderstand a feature as a bug or a bug as a feature since there are no requirements.\n- It is time-consuming.\n- If there is a bug in the application, you might not notice it.\n",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-25T22:08:08.187Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 24,
      "title": "Adhoc Testing",
      "description": "Adhoc Testing\n- No documentation\n- No test plan\n- Informal testing\n- Tester knows the application functionality\n- Random testing\n- Goal: Break the application or find corner defects\n- Used for any application\nMonkey Testing\n- No documentation\n- No test plan\n- Informal testing\n- Tester does not know the application functionality\n- Random testing\n- Goal: Break the application or find corner defects\n- Mostly used for gaming applications\nExploratory Testing\n- No documentation\n- No test plan\n- Informal testing\n- Tester does not know the application functionality\n- Random testing\n- Goal: Learn and explore the functionality of the application\n- Used for any application that is new to the tester\n",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-25T22:12:01.732Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 25,
      "title": "Sanity & Smoke Testing",
      "description": "1)smoke testing is done at the first build multiple times in every build to make sure the application can be install and we can perform the sanity testing can be done. And it is done by the Developer \n2)Sanity testing will be done after smoke testing  and it check the basic functionality, if there was a bug fixed we will check weither the bug is fixed and other functional is working or not.\nSmoke Testing\n- Done to check if the build is stable and testable\n- Performed by developers and testers\n- Can be done on unstable builds\n- Happens on initial builds\n- Part of basic testing\n- Done every time a new build is released\nSanity Testing\n- Done to check main functionalities after bug fixes or small changes\n- Performed by testers only\n- Requires a relatively stable build\n- Happens on stable builds\n- Part of regression testing\n- Used when there‚Äôs not enough time for full testing\n",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-25T22:10:20.596Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 26,
      "title": "End-To-End Testing",
      "description": "End-to-End Testing\n- It means testing the entire flow of the application from start to finish\n- Verifies that all modules work together and data flows correctly across them\n- Ensures that the system behaves as expected in a real-world scenario\nExample Flow:\n- Login\n- Add New Customer\n- Edit Customer\n- Delete Customer\n- Logout\nThis full sequence is tested to confirm that all parts of the system are integrated and functioning properly.\n",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "completed",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-26T14:53:03.173Z",
      "startDate": "",
      "dueDate": "",
      "subtasks": [],
      "deadlineStatus": "normal"
    },
    {
      "id": 27,
      "title": "STLC (Software Testing Life Cycle)",
      "description": "",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "pending",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-19T00:00:00.000Z"
    },
    {
      "id": 28,
      "title": "Use case, Test scenario & Test case",
      "description": "",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "pending",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-19T00:00:00.000Z"
    },
    {
      "id": 29,
      "title": "Test Environment and Execution",
      "description": "",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "pending",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-19T00:00:00.000Z"
    },
    {
      "id": 30,
      "title": "Defect Reporting",
      "description": "",
      "priority": "Medium",
      "tags": [
        "software-testing"
      ],
      "status": "pending",
      "createdAt": "2026-01-19T00:00:00.000Z",
      "updatedAt": "2026-01-19T00:00:00.000Z"
    },
    {
      "id": 31,
      "title": "Type of Testing Techniques",
      "description": "We have Two types of testing techniques one is static and another is dynamic . Static testing is all related to documents while Dynamic testing techniques is related to main software testing \n***Static Testing Technique****\n1, Review\n2, Walkthrough\n3, Inspection\n\n***Dynamic testing Technique***\n1,Unit Testing(testing singe module )\n2,Integration testing ( testing multiple modules ) both unit and integration tests are done by developer and it is called white  box test because the developer know about the code briefly so that's why called white box testing \n3,System testing done by QA and called black box testing beacuase the QA don't know about the code inside \n4, User Acceptance Testing is done by cline or customer \n",
      "startDate": null,
      "dueDate": null,
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-22T20:46:43.185Z",
      "updatedAt": "2026-01-22T21:13:07.400Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 32,
      "title": "STLC",
      "description": "üîπ STLC (Software Testing Life Cycle)\nSTLC is a step‚Äëby‚Äëstep process followed during testing to ensure software quality. It defines how testing is planned, designed, executed, and closed.\n\nSTLC Phases (Simple & Clear)\n1. Requirement Analysis\nUnderstand what needs to be tested.\n\nIdentify testable and non‚Äëtestable requirements.\n\nClarify gaps with BA/Dev if needed.\n\n2. Test Planning\nDefine the testing strategy.\n\nEstimate effort, resources, timelines.\n\nIdentify tools and risks.\n\n3. Test Case Design\nWrite detailed test cases.\n\nPrepare test data.\n\nReview and finalize test scenarios.\n\n4. Test Environment Setup\nPrepare the environment where testing will run.\n\nInstall builds, configure servers, databases, tools.\n\n5. Test Execution\nExecute test cases.\n\nLog defects.\n\nRetest and perform regression testing.\n\n6. Test Closure\nEnsure all planned tests are completed.\n\nPrepare test summary report.\n\nEvaluate quality and lessons learned.",
      "startDate": "",
      "dueDate": "",
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "pending",
      "createdAt": "2026-01-22T21:20:32.397Z",
      "updatedAt": "2026-01-22T22:07:28.587Z",
      "deadlineStatus": "completed"
    },
    {
      "id": 34,
      "title": "Non-Functional Testing",
      "description": "1. Performance Testing\n(Load Testing, Stress Testing, Volume Testing)\n- Load Testing:\nWe gradually increase the load ‚Äî for example, 1 user, then 2 users, then 3 users, and so on ‚Äî up to the required limit.\n- Stress Testing:\nWe suddenly add a high load (e.g., +20 users at once) or suddenly remove a large number of users (e.g., ‚Äì100 users) to see how the system behaves under extreme conditions.\n- Volume Testing:\nWe check how much data the system can handle ‚Äî how much data storage or data volume it can afford without performance issues.\n\n2. Security Testing\n(Authentication and Authorization)\n- Authentication: Verifies the user is who they claim to be (login, password, OTP).\n- Authorization: Verifies what the user is allowed to access after login (roles, permissions).\n\n3. Recovery Testing\nChecks how well the system recovers from crashes, failures, or unexpected shutdowns.\n\n4. Compatibility Testing\n- Forward Compatibility: Supports newer versions (e.g., new browser version).\n- Backward Compatibility: Supports previous versions.\n- Hardware Compatibility: Works correctly on different hardware configurations.\n\n5. Configuration Testing\nTests the application under different configurations (OS, browsers, network settings, memory, CPU, etc.).\n\n6. Installation Testing\nChecks installation and uninstallation processes to ensure they work smoothly without errors.\n\n7. Sanitation / Garbage Testing\nEnsures there are no extra or unwanted features that the customer did not request.\nExample:\nA developer adds a new page or feature that was not part of the requirement ‚Äî this should be flagged.\n",
      "startDate": "",
      "dueDate": "",
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-23T15:16:50.369Z",
      "updatedAt": "2026-01-25T17:11:35.922Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 35,
      "title": "Object properties testing",
      "description": "Object properties testing: Check the properties of objects present on the Application.\nEx: Enable, disable, visible, Focus...\nDatabase Testing / Backend Testing\nDML Operations (Data Manipulation Language):\n- insert\n- update\n- delete\n- select\n1. Object Properties Testing ‚Äì Examples\nExample 1: Login Button (Enabled/Disabled)\n- Scenario: User enters username but leaves password empty\n- Expected: Login button should remain disabled\nExample 2: Submit Button Visibility\n- Scenario: User selects ‚ÄúOther‚Äù in a dropdown\n- Expected: A text field labeled ‚ÄúPlease specify‚Äù becomes visible\nExample 3: Focus Check\n- Scenario: User presses the Tab key on the login page\n- Expected: Cursor moves from Username ‚Üí Password ‚Üí Login Button in correct order\nExample 4: Field Enabled/Disabled\n- Scenario: User checks ‚ÄúSame as Billing Address‚Äù\n- Expected: Shipping address fields become disabled\n\n2. Database Testing (DML Operations) ‚Äì Examples\nINSERT Example\n- Action: User registers a new account\n- Expected DB Result: A new row is inserted into users table with correct username, email, and timestamp\nUPDATE Example\n- Action: User updates their profile picture\n- Expected DB Result: profile_image column in users table is updated for that user ID\nDELETE Example\n- Action: User deletes an item from their shopping cart\n- Expected DB Result: Corresponding row is removed from cart_items table\nSELECT Example\n- Action: User logs in\n- Expected DB Result: System runs a SELECT query to fetch user credentials and returns correct user record",
      "startDate": null,
      "dueDate": null,
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-23T15:17:58.329Z",
      "updatedAt": "2026-01-25T22:09:43.993Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 36,
      "title": "Gray Box testing",
      "description": "Gray box testing means the tester has partial knowledge of how the system works internally and uses that information to design better tests.\nExample:\nYou know the database has a unique email constraint, so during registration you try entering an email that already exists to verify the system shows the correct error. and don't know who the login code functionality work that only developer know that's why it is called gray box testing \n",
      "startDate": null,
      "dueDate": null,
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-23T15:22:11.059Z",
      "updatedAt": "2026-01-25T16:59:09.744Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 37,
      "title": "Data Base Testing",
      "description": "üóÑÔ∏è Database Testing / Backend Testing\nüîπ DML Operations (Data Manipulation Language)\n- Insert ‚Üí User registers a new account; a new row is inserted into the users table.\n- Update ‚Üí User changes their phone number; the contact_number field is updated in the database.\n- Delete ‚Üí User deletes a saved address; the corresponding row is removed from addresses table.\n- Select ‚Üí System fetches user profile details during login using a SELECT query.\n\nüîπ Table & Column Level Validations\n- Column Type ‚Üí Ensure email column is of type VARCHAR, not INT.\n- Column Length ‚Üí Verify username column allows up to 50 characters.\n- Number of Columns ‚Üí Check that orders table has exactly 8 columns as per design.\n\nüîπ Relations Between Tables (Normalization)\n- Ensure customer_id in orders table correctly links to customers table via foreign key.\n- Verify no redundant data exists across tables (e.g., address stored separately, not repeated).\n\nüîπ Functions\n- Test a function that calculates total cart value based on item prices and quantities.\nüîπ Procedures\n- Validate a stored procedure that processes order placement and updates inventory.\nüîπ Triggers\n- Check that a trigger automatically logs changes to user_status in an audit table.\nüîπ Indexes\n- Ensure index on email column speeds up login query performance.\nüîπ Views\n- Test a view that shows active users with recent orders, combining data from multiple tables.\n",
      "startDate": null,
      "dueDate": null,
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-23T15:28:27.162Z",
      "updatedAt": "2026-01-25T16:59:03.133Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 38,
      "title": "Useability Testing",
      "description": "Useability means easiness  \nDeveloper should provide help menu or manual pdf document for user instructions how to use the application \nUsability Testing evaluates how easy, intuitive, and pleasant it is for real users to interact with the application. It focuses on the human experience, not just functionality. Strong usability testing helps ensure that users can complete tasks smoothly without confusion or frustration.\nüåü What Usability Testing Checks\n- Ease of navigation\nUsers should move through the application without getting lost or needing instructions.\n- Learnability\nNew users should understand how to use the system quickly, without a steep learning curve.\n- Efficiency\nCommon tasks should require minimal steps and effort.\n- Error prevention & recovery\nThe system should prevent mistakes where possible and provide clear, helpful messages when errors occur.\n- User satisfaction\nThe overall experience should feel smooth, intuitive, and pleasant.\n- Accessibility\nThe application should support users with disabilities‚Äîkeyboard navigation, screen readers, proper contrast, etc.\nüéØ Why It Matters\nEven a perfectly functional system fails if users struggle to use it. Usability testing ensures the product feels natural and user‚Äëfriendly, which directly impacts adoption, satisfaction, and business success.\n",
      "startDate": "",
      "dueDate": "",
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-25T16:23:24.972Z",
      "updatedAt": "2026-01-25T16:52:19.124Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 39,
      "title": "Regression Testing ",
      "description": "Regression Testing\nRegression testing is performed on a modified build to ensure that changes (adding, deleting, or modifying features) do not impact existing functionality.\nTypes of Regression Testing:\n\n1. Unit Regression Testing\n- Testing only the changes/modifications done by the developer.\n\n2. Regional Regression Testing\n- Testing the modified module along with the impacted modules.\n- An Impact Analysis meeting is conducted to identify impacted modules with QA & Dev teams.\n\n3. Full Regression Testing\n- Testing the main feature and the entire remaining application.\n- Example: If the developer has made changes in many modules, instead of identifying each impacted module, we perform one round of full regression.\n",
      "startDate": "",
      "dueDate": "",
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-25T17:43:00.636Z",
      "updatedAt": "2026-01-25T22:09:12.997Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 40,
      "title": "Software testing Terminology ",
      "description": "1)Regression Testing \n2)Re-testing(we test bug fixed module )\n3)Smoke testing and Sanity testing\n4)explority testing\n5)Adhoc Testing\n6)Monkey testing\n7)Positive and negative testing\n8)End To End Testing\n9)Globalization and Localization Testing ",
      "startDate": "",
      "dueDate": "",
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-25T18:08:48.866Z",
      "updatedAt": "2026-01-25T22:27:33.367Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 41,
      "title": "Negative and positive testing ",
      "description": "\nNegative Testing\n- Testing the application with invalid inputs\n- Purpose: To check if the system handles errors properly\n- The application should either reject the input or show an error message\nExample:\nIf a field says ‚ÄúEnter only numbers‚Äù and you type abcdef, that‚Äôs negative testing.\nThe system should not accept it or should show a message like ‚ÄúInvalid input.‚Äù\nPositive Testing\n- Testing the application with valid inputs\n- Checks if the system behaves as expected when correct data is entered\n- The goal is to confirm that the application accepts valid input and performs the correct action\nExample:\nIf a field accepts only numbers, entering 99999 is positive testing.\nThe system should accept it without errors.\n\n",
      "startDate": null,
      "dueDate": null,
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-25T22:11:42.409Z",
      "updatedAt": "2026-01-25T22:11:44.938Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 42,
      "title": "Equivalence Class Partition   ",
      "description": "in this Test design technique we divides data in to multiple classes and then check it for example checking 1-500 we check the invalid portion which is -0 and same the numbers after 500 which is also invalid portion we check that too and then check the number between 1-500 which is positive test case.  ",
      "startDate": null,
      "dueDate": null,
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-26T14:57:45.360Z",
      "updatedAt": "2026-01-26T15:08:45.736Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 43,
      "title": "Boundary Value Analysis (BVA)",
      "description": "Boundary Value Analysis (BVA)\nBVA technique used to check Boundaries of the input.\nEnter a Age:\n- Allow Digits from 18--35\nBoundary Values:\n- Min-1 = 17 (Fail)\n- Min = 18 (Pass)\n- Min+1 = 19 (Pass)\n- Max-1 = 34 (Pass)\n- Max = 35 (Pass)\n- Max+1 = 36 (Fail)\nSummary of Results:\n- Min = 18 (Pass)\n- Min-1 = 17 (Fail)\n- Min+1 = 19 (Pass)\n- Max = 35 (Pass)\n- Max-1 = 34 (Pass)\n- Max+1 = 36 (Fail)\n",
      "startDate": null,
      "dueDate": null,
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-26T15:03:47.685Z",
      "updatedAt": "2026-01-26T15:08:43.004Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 44,
      "title": "Input domain Testing",
      "description": "in this testing we test the value in input filed (text box) using ECP and BVA techniques ",
      "startDate": null,
      "dueDate": null,
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-26T15:11:04.475Z",
      "updatedAt": "2026-01-26T15:11:09.629Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 45,
      "title": "Decision Table Technique",
      "description": " What Is Decision Table Testing?\nDecision Table Testing is a test design technique used when the system‚Äôs behavior depends on multiple conditions.\nIt helps you cover all possible combinations of inputs and rules in a structured way.\nDecision Table Example...\nConditions:\n- Condition1: Account already approved\n- Condition2: OTP Matched\n- Condition3: Sufficient Money in the Account\nActions:\n- Action1: Transfer Money\n- Action2: Show message 'Insufficient Amount'\n- Action3: Block the transaction in case of suspicious transaction\nHandwritten Notes:\n- TC1: Valid\n- TC2: No Gi\n- TC5: Invalid\n- Circle around \"Execute\" in TC4 under Action3\n- Check marks above TC1 to TC5\n- Check mark next to TC5 Condition2 row\n",
      "startDate": null,
      "dueDate": null,
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-26T15:38:06.470Z",
      "updatedAt": "2026-01-26T15:50:12.561Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 46,
      "title": "State Transection Technique and table",
      "description": "üîÑ What Is State Transition Testing?\nState Transition Testing is a technique used to test how a system behaves when it moves from one state to another based on user actions or inputs.\nIt‚Äôs useful when:\n- The system has different states\n- The output depends on past actions\n- You want to test valid and invalid transitions\nState Transition Example\nStates:\n- S1: FIRST ATTEMPT\n- S2: SECOND ATTEMPT\n- S3: THIRD ATTEMPT\n- S4: HOME PAGE\n- S5: ACCOUNT LOCKED\nTransitions:\n- From S1:\n- Correct password ‚Üí S4\n- Incorrect password ‚Üí S2\n- From S2:\n- Correct password ‚Üí S4\n- Incorrect password ‚Üí S3\n- From S3:\n- Correct password ‚Üí S4\n- Incorrect password ‚Üí S5\nState Transition Table:\n|  |  |  |  | \n|  |  |  |  | \n|  |  |  |  | \n|  |  |  |  | \n|  |  |  |  | \n|  |  |  |  | \n\n\n\n\n",
      "startDate": "",
      "dueDate": "",
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-26T15:47:00.984Z",
      "updatedAt": "2026-01-26T15:50:54.619Z",
      "deadlineStatus": "normal"
    },
    {
      "id": 47,
      "title": "Error Quessing",
      "description": "Test Case: Error Guessing ‚Äì Form Submission Validation\nTest Objective:\nVerify that the system handles unexpected or invalid inputs based on tester intuition and experience.\nTest Technique:\nError Guessing\nTest Steps:\n- Open the target form page.\n- Leave all fields blank and click Submit.\n- Enter alphabets (e.g., \"abc\") in a numeric-only field.\n- Enter special characters (e.g., \"@#$\") in restricted fields.\n- Enter extremely long text in a short input field.\n- Skip mandatory fields and attempt submission.\nExpected Results:\n- System should display appropriate error messages.\n- Form should not be submitted.\n- Numeric fields should reject non-numeric input.\n- Mandatory fields should trigger validation alerts.\nNotes:\nThis test relies on tester‚Äôs experience to guess likely failure points not covered by formal test design.\n",
      "startDate": null,
      "dueDate": null,
      "priority": "Medium",
      "tags": [],
      "subtasks": [],
      "status": "completed",
      "createdAt": "2026-01-26T15:51:40.542Z",
      "updatedAt": "2026-01-26T15:51:43.637Z",
      "deadlineStatus": "normal"
    }
  ],
  "nextId": 48
}